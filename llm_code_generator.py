"""
OG-AI Advanced LLM Code Generator
Generates complete, production-ready code using AI models
Keeps it gangster while being smart as fuck
"""

import os
import re
from typing import Dict, List, Optional, Tuple
from datetime import datetime


class LLMCodeGenerator:
    """
    Smart-ass code generator that creates REAL working code
    Not just snippets - full production shit
    """
    
    CODE_TEMPLATES = {
        'python_api': {
            'description': 'FastAPI REST API with database',
            'template': '''"""
{name} - Professional REST API
Generated by OG-AI - The realest code generator in the game
"""

from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime
import uvicorn

app = FastAPI(
    title="{name}",
    description="{description}",
    version="1.0.0"
)

# CORS - Let everyone hit this endpoint
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Data Models
class {ModelName}(BaseModel):
    """Main data model"""
    id: Optional[int] = None
    name: str = Field(..., description="Name of the {model_lower}")
    description: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.now)
    
    class Config:
        json_schema_extra = {{
            "example": {{
                "name": "Example {ModelName}",
                "description": "This is fire!"
            }}
        }}

# In-memory storage (replace with real DB in production)
storage: List[{ModelName}] = []
next_id = 1

@app.get("/")
async def root():
    """Health check - Make sure this bitch is running"""
    return {{
        "status": "lit",
        "message": "{name} API is live! No cap.",
        "version": "1.0.0"
    }}

@app.get("/{endpoint}", response_model=List[{ModelName}])
async def get_all_{endpoint}():
    """Get all {endpoint} - Return the whole squad"""
    return storage

@app.get("/{endpoint}/{{item_id}}", response_model={ModelName})
async def get_{endpoint_singular}(item_id: int):
    """Get a single {endpoint_singular} by ID"""
    for item in storage:
        if item.id == item_id:
            return item
    raise HTTPException(status_code=404, detail=f"{ModelName} not found, bruh")

@app.post("/{endpoint}", response_model={ModelName})
async def create_{endpoint_singular}(item: {ModelName}):
    """Create new {endpoint_singular} - Add to the gang"""
    global next_id
    item.id = next_id
    next_id += 1
    storage.append(item)
    return item

@app.put("/{endpoint}/{{item_id}}", response_model={ModelName})
async def update_{endpoint_singular}(item_id: int, updated_item: {ModelName}):
    """Update existing {endpoint_singular}"""
    for i, item in enumerate(storage):
        if item.id == item_id:
            updated_item.id = item_id
            storage[i] = updated_item
            return updated_item
    raise HTTPException(status_code=404, detail=f"{ModelName} not found")

@app.delete("/{endpoint}/{{item_id}}")
async def delete_{endpoint_singular}(item_id: int):
    """Delete a {endpoint_singular} - Boot 'em out"""
    global storage
    storage = [item for item in storage if item.id != item_id]
    return {{"message": "{ModelName} deleted successfully", "id": item_id}}

if __name__ == "__main__":
    print("ðŸ”¥ {name} API starting up...")
    print("ðŸ“¡ Running on http://0.0.0.0:8000")
    print("ðŸ“š API Docs: http://0.0.0.0:8000/docs")
    uvicorn.run(app, host="0.0.0.0", port=8000)
'''
        },
        
        'python_cli': {
            'description': 'Command-line tool with argparse',
            'template': '''"""
{name} - Professional CLI Tool
Created by OG-AI - Command line boss
"""

import argparse
import sys
from typing import Optional


def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(
        description="{description}",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        'command',
        choices=['run', 'test', 'clean'],
        help='Command to execute'
    )
    
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Enable verbose output'
    )
    
    parser.add_argument(
        '--config', '-c',
        type=str,
        help='Config file path'
    )
    
    args = parser.parse_args()
    
    if args.verbose:
        print(f"ðŸ”¥ Running command: {{args.command}}")
    
    # Execute command
    if args.command == 'run':
        run_command(args)
    elif args.command == 'test':
        test_command(args)
    elif args.command == 'clean':
        clean_command(args)


def run_command(args):
    """Execute run command"""
    print("ðŸš€ Running {name}...")
    # Your logic here
    print("âœ… Complete!")


def test_command(args):
    """Execute test command"""
    print("ðŸ§ª Running tests...")
    # Your test logic here
    print("âœ… All tests passed!")


def clean_command(args):
    """Execute clean command"""
    print("ðŸ§¹ Cleaning up...")
    # Your cleanup logic here
    print("âœ… Clean!")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\\nðŸ‘‹ Interrupted. Peace out!")
        sys.exit(0)
    except Exception as e:
        print(f"âŒ Error: {{e}}")
        sys.exit(1)
'''
        },
        
        'python_scraper': {
            'description': 'Web scraper with BeautifulSoup',
            'template': '''"""
{name} - Professional Web Scraper
Built by OG-AI - Scraping the web like a boss
"""

import requests
from bs4 import BeautifulSoup
from typing import List, Dict, Optional
import json
from datetime import datetime


class {ClassName}:
    """Professional web scraper"""
    
    def __init__(self, base_url: str):
        """Initialize scraper"""
        self.base_url = base_url
        self.session = requests.Session()
        self.session.headers.update({{
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }})
    
    def fetch_page(self, url: str) -> Optional[BeautifulSoup]:
        """Fetch and parse a page"""
        try:
            response = self.session.get(url, timeout=10)
            response.raise_for_status()
            return BeautifulSoup(response.content, 'html.parser')
        except Exception as e:
            print(f"âŒ Error fetching {{url}}: {{e}}")
            return None
    
    def scrape_{target}(self) -> List[Dict]:
        """Scrape {target} from the website"""
        soup = self.fetch_page(self.base_url)
        if not soup:
            return []
        
        results = []
        
        # Find all {target} (customize selectors)
        items = soup.find_all('div', class_='{target}-item')
        
        for item in items:
            try:
                data = {{
                    'title': item.find('h2').get_text(strip=True),
                    'description': item.find('p').get_text(strip=True),
                    'link': item.find('a')['href'] if item.find('a') else None,
                    'scraped_at': datetime.now().isoformat()
                }}
                results.append(data)
            except Exception as e:
                print(f"âš ï¸  Skipped item: {{e}}")
                continue
        
        return results
    
    def save_results(self, results: List[Dict], filename: str = 'scraped_data.json'):
        """Save scraped data to JSON file"""
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False)
        print(f"ðŸ’¾ Saved {{len(results)}} items to {{filename}}")


if __name__ == "__main__":
    # Example usage
    scraper = {ClassName}("{example_url}")
    results = scraper.scrape_{target}()
    
    print(f"ðŸ”¥ Scraped {{len(results)}} items!")
    
    if results:
        scraper.save_results(results)
        print("âœ… Scraping complete!")
'''
        },
        
        'react_component': {
            'description': 'React functional component',
            'template': '''import React, {{ useState, useEffect }} from 'react';
import PropTypes from 'prop-types';
import './{{ComponentName}}.css';

/**
 * {{ComponentName}} - {description}
 * Created by OG-AI - React component boss
 */
const {{ComponentName}} = ({{ {props} }}) => {{
  const [state, setState] = useState({{
    loading: false,
    data: null,
    error: null
  }});

  useEffect(() => {{
    // Component mounted - Do your thing
    console.log('ðŸ”¥ {{ComponentName}} mounted!');
    
    return () => {{
      // Cleanup when unmounted
      console.log('ðŸ‘‹ {{ComponentName}} unmounted');
    }};
  }}, []);

  const handleAction = () => {{
    setState(prev => ({{ ...prev, loading: true }}));
    
    // Your logic here
    setTimeout(() => {{
      setState(prev => ({{ 
        ...prev, 
        loading: false,
        data: 'Action complete!' 
      }}));
    }}, 1000);
  }};

  if (state.loading) {{
    return <div className="loading">Loading...</div>;
  }}

  if (state.error) {{
    return <div className="error">Error: {{state.error}}</div>;
  }}

  return (
    <div className="{{component-name}}">
      <h2>{{ComponentName}}</h2>
      <p>{description}</p>
      
      <button onClick={{handleAction}} className="btn-primary">
        Take Action
      </button>
      
      {{state.data && (
        <div className="result">
          <p>{{state.data}}</p>
        </div>
      )}}
    </div>
  );
}};

{{ComponentName}}.propTypes = {{
  // Define your prop types
  title: PropTypes.string,
  onAction: PropTypes.func
}};

{{ComponentName}}.defaultProps = {{
  title: '{{ComponentName}}',
  onAction: () => {{}}
}};

export default {{ComponentName}};
'''
        }
    }
    
    def __init__(self):
        """Initialize the gangster code generator"""
        self.generated_files = []
    
    def generate_api(self, name: str, description: str, model_name: str, endpoint: str) -> str:
        """Generate a complete FastAPI application"""
        template = self.CODE_TEMPLATES['python_api']['template']
        
        # Process names
        endpoint_singular = endpoint.rstrip('s') if endpoint.endswith('s') else endpoint
        model_lower = model_name.lower()
        
        code = template.format(
            name=name,
            description=description,
            ModelName=model_name,
            model_lower=model_lower,
            endpoint=endpoint,
            endpoint_singular=endpoint_singular
        )
        
        return code
    
    def generate_cli(self, name: str, description: str) -> str:
        """Generate a CLI tool"""
        template = self.CODE_TEMPLATES['python_cli']['template']
        code = template.format(name=name, description=description)
        return code
    
    def generate_scraper(self, name: str, target: str, base_url: str) -> str:
        """Generate a web scraper"""
        template = self.CODE_TEMPLATES['python_scraper']['template']
        class_name = ''.join(word.capitalize() for word in name.split())
        
        code = template.format(
            name=name,
            ClassName=class_name,
            target=target,
            example_url=base_url
        )
        
        return code
    
    def generate_react_component(self, component_name: str, description: str, props: str = "title, onAction") -> str:
        """Generate a React component"""
        template = self.CODE_TEMPLATES['react_component']['template']
        component_class = component_name.lower().replace(' ', '-')
        
        code = template.format(
            ComponentName=component_name.replace(' ', ''),
            description=description,
            props=props,
            component-name=component_class
        )
        
        return code
    
    def detect_generation_request(self, message: str) -> Optional[Dict]:
        """
        Detect what kind of code the user wants
        Smart understanding of ghetto and technical requests
        """
        message_lower = message.lower()
        
        # API detection
        api_triggers = ['api', 'rest', 'endpoint', 'backend', 'server', 'make me an api']
        if any(trigger in message_lower for trigger in api_triggers):
            # Extract API details
            name_match = re.search(r'(?:called|named|for)\s+([a-zA-Z0-9_\s]+)', message)
            name = name_match.group(1).strip() if name_match else "MyAPI"
            
            return {
                'type': 'api',
                'name': name,
                'description': f"REST API for {name}",
                'model': name.title().replace(' ', ''),
                'endpoint': name.lower().replace(' ', '_') + 's'
            }
        
        # CLI detection
        cli_triggers = ['cli', 'command line', 'terminal tool', 'script']
        if any(trigger in message_lower for trigger in cli_triggers):
            name_match = re.search(r'(?:called|named|for)\s+([a-zA-Z0-9_\s]+)', message)
            name = name_match.group(1).strip() if name_match else "MyCLI"
            
            return {
                'type': 'cli',
                'name': name,
                'description': f"Command-line tool for {name}"
            }
        
        # Scraper detection
        scraper_triggers = ['scrap', 'crawl', 'fetch', 'extract', 'pull data']
        if any(trigger in message_lower for trigger in scraper_triggers):
            url_match = re.search(r'https?://[^\s]+', message)
            url = url_match.group(0) if url_match else "https://example.com"
            
            target_match = re.search(r'(?:scrape|fetch|get)\s+([a-zA-Z0-9_\s]+)', message)
            target = target_match.group(1).strip() if target_match else "items"
            
            return {
                'type': 'scraper',
                'name': f"{target.title()} Scraper",
                'target': target.lower(),
                'url': url
            }
        
        # React component detection
        react_triggers = ['react', 'component', 'jsx', 'frontend']
        if any(trigger in message_lower for trigger in react_triggers):
            name_match = re.search(r'(?:called|named)\s+([a-zA-Z0-9_\s]+)', message)
            name = name_match.group(1).strip() if name_match else "MyComponent"
            
            return {
                'type': 'react',
                'name': name,
                'description': f"React component for {name}"
            }
        
        return None
    
    def generate_code_from_request(self, message: str) -> Tuple[Optional[str], Optional[str]]:
        """
        Generate code based on user request
        Returns (code, explanation)
        """
        request = self.detect_generation_request(message)
        
        if not request:
            return None, None
        
        code = None
        explanation = ""
        
        if request['type'] == 'api':
            code = self.generate_api(
                request['name'],
                request['description'],
                request['model'],
                request['endpoint']
            )
            explanation = f"ðŸ”¥ Yo! I just cooked up a COMPLETE FastAPI application for '{request['name']}'! This shit has:\n" \
                         f"- Full CRUD operations (Create, Read, Update, Delete)\n" \
                         f"- Proper data models with validation\n" \
                         f"- CORS enabled so you can hit it from anywhere\n" \
                         f"- Auto-generated API docs at /docs\n" \
                         f"- Production-ready structure\n\n" \
                         f"Just save this to a file and run: python <filename>.py\n" \
                         f"Then go to http://localhost:8000/docs to see the magic! No cap, this shit works!"
        
        elif request['type'] == 'cli':
            code = self.generate_cli(request['name'], request['description'])
            explanation = f"ðŸ’» Ayyy! Built you a fire CLI tool for '{request['name']}'! Features:\n" \
                         f"- Argparse for professional command handling\n" \
                         f"- Multiple commands (run, test, clean)\n" \
                         f"- Verbose mode and config file support\n" \
                         f"- Clean error handling\n\n" \
                         f"Use it like: python script.py run --verbose"
        
        elif request['type'] == 'scraper':
            code = self.generate_scraper(request['name'], request['target'], request['url'])
            explanation = f"ðŸ•·ï¸ Bet! I made you a web scraper for '{request['target']}'! This beast has:\n" \
                         f"- BeautifulSoup for parsing HTML\n" \
                         f"- Proper error handling\n" \
                         f"- JSON export functionality\n" \
                         f"- Session management\n\n" \
                         f"Customize the CSS selectors for your specific target site!"
        
        elif request['type'] == 'react':
            code = self.generate_react_component(request['name'], request['description'])
            explanation = f"âš›ï¸ Yo! Created a React component '{request['name']}'! Got all the sauce:\n" \
                         f"- Hooks (useState, useEffect)\n" \
                         f"- Prop validation with PropTypes\n" \
                         f"- Loading and error states\n" \
                         f"- Clean CSS class names\n\n" \
                         f"Drop this in your React project and you're good to go!"
        
        return code, explanation


# Singleton instance
_code_generator = None

def get_code_generator() -> LLMCodeGenerator:
    """Get or create the global code generator"""
    global _code_generator
    if _code_generator is None:
        _code_generator = LLMCodeGenerator()
    return _code_generator
